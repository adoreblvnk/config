#!/bin/bash
# /usr/bin

set -euo pipefail

# constants
readonly DOTFILES="dotfiles/"
readonly CONFIG="config.yaml"
# deps_file="deps.list"
# install_file="install.list"
# readonly FILTER_COMMENT='map(select(startswith("#") | not))'

usage() {
  cat <<EOF
TIDES (The Idempotent Dev Environment Setup) is a post-install, update, & dotfile manager

Usage: tides [OPTIONS]

Commands:
  check         Installs dependencies, Python (via pyenv), Cargo (via rustup), & firmware packages
  install, i    Installs all packages. Auto-invokes \`configure\` when done
  update, u     Updates & upgrades apt, flatpak, cargo, pip packages
  configure, c  Dotfile manager (via Stow)
  help, h       Print help information

Configuration:
  Customise each command's behaviour by modifying the \`config.json\` file.
  Optionally, packages to be installed can be managed via \`deps.list\` & \`install.list\` text file.
  The config schema of \`config.json\` is available at \`README.md\`.

Example:
  tides configure

EOF
}

error_msg() {
  cat <<EOF
Error: Invalid argument(s)

EOF
}

check() {
  echo check
}

install() {
  if [[ $(yq '.config.configure.check' $CONFIG) == true ]]; then
    check
  fi

  # install apt packages
  if [[ $(yq '.config.install.apt | length' $CONFIG) -gt 0 ]]; then
    sudo apt-get update -qqy
    # shellcheck disable=SC2046
    sudo apt-get install -qy $(yq '.config.install.apt[]' $CONFIG)
  fi

  # install ppa packages
  local no_of_ppa_pkgs=$(yq '.config.install.ppa | length' $CONFIG)
  if [[ $no_of_ppa_pkgs -gt 0 ]]; then
    # add ppa repos (& their gpg keys automatically)
    for ((i = 0; i < no_of_ppa_pkgs; i++)); do
      sudo apt-add-repository -y \
        "$(yq ".config.install.ppa[$i].ppaUrl" $CONFIG)"
    done
    sudo apt-get update -q
    # shellcheck disable=SC2046
    sudo apt-get install -qy $(yq '.config.install.ppa[].packages[]' $CONFIG)
  fi

  # install from apt alternative sources
  local no_of_alt_sources=$(yq '.config.install.aptAltSources | length' $CONFIG)
  if [[ $no_of_alt_sources -gt 0 ]]; then
    # setting up signing keys & repo entries
    for ((i = 0; i < no_of_alt_sources; i++)); do
      local alt_pkg_obj=$(yq ".config.install.aptAltSources[$i]" $CONFIG)

      # download gpg key from remote
      if [[ $(yq '.gpgKeyPath' <<<"$alt_pkg_obj") == *.asc ]]; then
        sudo curl -fsSL -o "$(yq '.gpgKeyPath' <<<"$alt_pkg_obj")" \
          "$(yq '.remoteGpgKey' <<<"$alt_pkg_obj")"
      elif [[ $(yq '.gpgKeyPath' <<<"$alt_pkg_obj") == *.gpg ]]; then
        # dearmor if key is required to be in gpg format
        sudo curl -fsSL "$(yq '.remoteGpgKey' <<<"$alt_pkg_obj")" \
          | sudo gpg --dearmor --yes -o "$(yq '.gpgKeyPath' <<<"$alt_pkg_obj")"
      fi

      # add repo entry into sources.list.d
      local source_file_full_path="/etc/apt/sources.list.d/$(yq '.sourceFile' <<<"$alt_pkg_obj").list"
      eval echo "$(yq '.repo' <<<"$alt_pkg_obj")" \
        | sudo tee "$source_file_full_path" >/dev/null

      # perform pinning if pinning entry exists
      if [[ $(yq '.pinning' <<<"$alt_pkg_obj") != false ]]; then
        # perform pinning to prioritise
        local pref_file="/etc/apt/preferences.d/$(yq '.sourceFile' <<<$alt_pkg_obj)"
        yq '.pinning' <<<"$alt_pkg_obj" \
          | sudo tee "$pref_file" >/dev/null
      fi
    done
    # install packages
    sudo apt-get update -q
    # disable shellcheck to enable installing multiple packages
    # shellcheck disable=SC2046
    sudo apt-get install -qy \
      $(yq '.config.install.aptAltSources[].packages[]' $CONFIG)
  fi

  # install flatpaks
  if [[ $(yq '.config.install.flatpak | length' $CONFIG) -gt 0 ]] \
    && command -v flatpak &>/dev/null; then
    # shellcheck disable=SC2046
    flatpak install -y flathub $(yq '.config.install.flatpak[]' $CONFIG)
  fi

  # install pip cli packages
  if [[ $(yq '.config.install.pip | length' $CONFIG) -gt 0 ]] \
    && command -v pyenv &>/dev/null; then
    local py_ver=$(yq '.config.check.python.version' "$CONFIG")
    # shellcheck disable=SC2046
    $py_ver -m pip install $(yq '.config.install.pip[]' $CONFIG)
  fi

  # install cargo packages
  if [[ $(yq '.config.install.cargo | length' $CONFIG) -gt 0 ]] \
    && command -v cargo &>/dev/null; then
    local rust_pkgs
    mapfile -t rust_pkgs < <(
      yq '.config.install.cargo[]' $CONFIG
    )
    for pkg in "${rust_pkgs[@]}"; do
      # disable to enable installing with options
      # shellcheck disable=SC2086
      cargo install $pkg
    done
  fi

  # install binary packages
  local no_of_binaries=$(yq '.config.install.binaries | length' $CONFIG)
  if [[ $no_of_binaries -gt 0 ]]; then
    mkdir -p $HOME/Applications
    for ((i = 0; i < no_of_binaries; i++)); do
      local binary_obj=$(yq ".config.install.binaries[$i]" $CONFIG)
      if [[ $(yq '.name' <<<"$binary_obj") == *.AppImage ]]; then
        curl -fsSL -o "$HOME/Applications/$(yq '.name' <<<"$binary_obj")" \
          "$(yq '.url' <<<"$binary_obj")"
        chmod +x "$HOME/Applications/$(yq '.name' <<<"$binary_obj")"
      fi
    done
  fi
}

update() {
  if [[ $(yq '.config.update.check' $CONFIG) == true ]]; then
    check
  fi

  if [[ $(yq '.config.update.apt.apt' $CONFIG) == true ]]; then
    # update apt
    sudo apt-get -qq update
    sudo apt-get -qy upgrade
    # aptFull removes old archive files & unused packages with their config files
    if [[ $(yq '.config.update.apt.aptFull' $CONFIG) == true ]]; then
      sudo apt-get -qy autoclean
      sudo apt-get -qy --purge autoremove
    fi
  fi

  # update flatpak
  if [[ $(yq '.config.update.flatpak' $CONFIG) == true ]] \
    && command -v flatpak &>/dev/null; then
    flatpak update -y
  fi

  # update pip
  if [[ $(yq '.config.update.pip' $CONFIG) == true ]] \
    && command -v pyenv &>/dev/null; then
    # TODO: test if pyenv update updates python patch version too
    pyenv update
    local py_ver=$(yq '.config.check.python.version' $CONFIG)
    $py_ver -m pip install --upgrade pip
  fi

  # update cargo
  if [[ $(yq '.config.update.cargo' $CONFIG) == true ]] \
    && command -v rustup &>/dev/null; then
    # update rust first
    rustup update
    cargo install-update -a
  fi

  # update yq
  if [[ $(yq '.config.update.other.yq' $CONFIG) ]]; then
    # get local yq version & parse it
    local_yq_ver=$(yq --version | cut -d ' ' -f 4)
    # get latest yq version
    latest_yq_ver=$(
      curl -s https://api.github.com/repos/mikefarah/yq/releases/latest \
        | yq -o=json -r '.tag_name'
    )
    if [[ $local_yq_ver == "$latest_yq_ver" ]]; then
      # download & install yq
      sudo curl -sSL -o /usr/bin/yq \
        https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
      sudo chmod +x /usr/bin/yq
    fi
  fi

  # zellij delete all other sessions, including exited ones
  if [[ $(yq '.config.update.other.zellijClear' $CONFIG) == true ]] \
    && command -v zellij &>/dev/null; then
    zellij delete-all-sessions -y
  fi
}

configure() {
  if [[ $(yq '.config.configure.check' $CONFIG) == true ]]; then
    check
  fi

  # dotfile manager implementation via Stow
  if [[ $(yq '.config.configure.dotfiles | length' $CONFIG) -gt 0 ]] \
    && command -v stow &>/dev/null; then
    local packages
    mapfile -t packages < <(
      yq -r '.config.configure.dotfiles[]' $CONFIG
    )
    echo "${packages[@]}"
    for package in "${packages[@]}"; do
      # symlink between tides & actual dotfiles
      # --no-folding stows individual files instead of directories
      # --adopt replaces tides' dotfiles with system ones. this is needed as
      # Stow throws an error if there are existing system dotfiles. mitigated
      # if .config.configure.stowMode is set to "override".
      stow --no-folding --adopt -v -d "dotfiles/" -t "$HOME" "$package"
      # override system files with tides' dotfiles
      if [[ $(yq -r '.config.configure.stowMode' $CONFIG) == "override" ]] \
        && git status --porcelain --untracked-files=no $DOTFILES \
        | grep -q "$package"; then
        # NOTE: commit any new changes made to dotfiles as they will be reset
        # if there are any changes detected.
        # TODO: explore a cleaner option than git restore
        git restore "$DOTFILES/$package/"
      fi
    done
  fi
}

main() {
  # download & install yq if not installed
  if ! command -v yq &>/dev/null; then
    sudo curl -sSL -o /usr/bin/yq \
      https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
    sudo chmod +x /usr/bin/yq
  fi

  [[ $# -gt 0 ]] || {
    usage
    error_msg
    exit 1
  }

  while [[ $# -gt 0 ]]; do
    case $1 in
      check) check ;;
      install | i) install ;;
      update | u) update ;;
      configure | c) configure ;;
      help | h)
        usage
        # exit 0
        ;;
      *)
        usage
        error_msg
        exit 1
        ;;
    esac
    shift
  done
}

main "$@"
